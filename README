Project 2 Goals

Part 1: Build a thread safe topic queue
Part 2: Implement A thread pool to use topic queue
Part 3: Build a program to get publishers and subscribers. Assign them to proxies in the thread pool.
Part 4: Read Publisher and Subscriber command from file.
Part 5: produce HTML file from subscribers request showing the image + caption read.


How to Test

Part 1: Use roscoes test code or write a similar test
Part 2: Create a thread pool. In main, assign many more publishers and subscribers to the pool.
Part 3: Rewrite main to interpret to command file.
Part 4: 1:1 P/S, N:1 P/S, N:M P/S, producers add to only one queue, then multiple, same with subs
Part 5: Look at the HTML page generated by the code


TODO:
write readers for pub/sub/server files - use strtok_r for thread safety
succesfully wait on semaphore
run simple tests with publishers, subscribers, and clean up




TOASK:
Is it correct to have a consumer struct with a pointer to the TQ_list, then pass that thread the single pointer to the consumer struct but still be able to access all of the topics?
Same question for publisher and subscriber, they all need access to all of the topics Is using the thread safe bounded queue code enough to be synchronized or do other spots need to be synchronized.
Why when I change enqueue to also set the timeval and entry number I no longer pass simple order test.
Should the subscriber struct have a list showing the progress of last entry for every topic?

how to set up publisher/subscriber test?
	init a topic_queue
	init a list of topic_entries
	have the pubs/subs enqueue/getentry the queue.

do you read through the server input file to find out how many topics, then allocate that many queues
or use dynamic sized list.



DONE:
boundedqueue.c passes all tests as long as it doesnt modify the topic entry?



Project 2 Lab 2

new files in project 2 folder on canvas

# pubs = # subs = # topics = 1

struct topicQueue = Malloc(topicQueue)
pthread create(publisher)
pthread create(subscriber)
pthread create(cleanUP)

strtok is not thread safe

MAIN
|___publish thread
| |_p1	      |__Enqueue
| |_p2
|
|___subscriber thread
| |_s1        |__getEntry
| |_s2
|
|___cleanUp thread
              |__dequeue

//delta is a global
//
//starting at the TAIL the oldest entry
void cleanup(void * topicQueue){
	time = gettimeofday();
	delta = 5
	age = |topicqueue->tail.timestamp - time|
	if (age > delta){
		dequeue(topic);
	}
	//do this for all entries in the queue;	
}


subscriber
	entrynum = 0
	get entry(entrynum)
	case:
		entry is in queue : return 1
	case:
		entry not in queue and queue is empty : return entry number


struct type *ptr;
void *address = ptr;
ptr = (struct type *)address



void Publisher(void * TopicQueue){
	struct TQ = Topic Queue;
	open PublisherFile
	for Line in file
		get topic number
		get URL
		get caption
		Enque(topic #, URL, caption)
		get time to sleep
		sleep()
}
	
void Subscriber(void * TopicQueue){
	struct TQ = TopicQueue
	open SubscriberFile
	for Line in file
		get topicID
		Dequeue(topicID);
		get time to sleep
		sleep()




void *producerRoutine(void *i){
	//wait on semaphore
	//enqueue
	//sleep
	int *i_ptr = (int *)i;
	fprintf(stderr, "producer %d\n", *i_ptr);
	return NULL;
}

void *consumerRoutine(void *i){
	//wait on semaphore
	//getentry - put
	//sleep	
	fprintf(stderr, "consumer\n");
	return NULL;
}

void *cleanupRoutine(void *i){
	//wait on semaphore//dequeue - get
	//sleep
	return NULL;
}




void *producerRoutine(void *i){
	//wait on semaphore
	//enqueue
	//sleep
	int *i_ptr = (int *)i;
	fprintf(stderr, "producer %d\n", *i_ptr);
	return NULL;
}

void *consumerRoutine(void *i){
	//wait on semaphore
	//getentry - put
	//sleep	
	fprintf(stderr, "consumer\n");
	return NULL;
}

void *cleanupRoutine(void *i){
	//wait on semaphore//dequeue - get
	//sleep
	return NULL;
}



